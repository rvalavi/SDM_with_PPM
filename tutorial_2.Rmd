---
title: 'Tutorial 2: point process advanced topics'
author: "Ian Flint and Roozbeh Valavi"
date: "`r Sys.Date()`"
output: 
  pdf_document
vignette: >
  %\VignetteIndexEntry{Species distribution modelling with Poisson point processes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
always_allow_html: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, tidy.opts = list(width.cutoff = 80), fig.align="center", message = FALSE, warning = FALSE, fig.height = 5, fig.width = 5)

set.seed(1)
```



## Setup and R libraries

```{r}
library(spatstat) # fitting and exploring ppm models
library(terra) # working with raster data

```



## Cox process

Spatstat can handle many different types of correlation structures between individuals of the species.
You would usually supply an `interaction` parameter to `spatstat.core::ppm`.
However, initial analysis suggested attraction between the individuals, in which case a doubly-stochastic (Cox) point process is more appropriate.
Fitting such point processes uses another function, as shown below.

<!-- ```{r} -->
  <!-- fit_cox <- spatstat::kppm(as.formula(formula), covariates = covariates, clusters = "LGCP") -->
  <!-- summary(fit_cox) -->
  <!-- ``` -->
  
  <!-- A nice way to appreciate the difference in the underlying model is to draw from the fitted distribution. -->
  <!-- This can easily be done for the fitted Poisson point process. -->
  
  <!-- ```{r} -->
  <!-- draw_ppp <- spatstat::simulate.ppm(fit) -->
  <!-- plot(draw_ppp) -->
  <!-- ``` -->
  
  <!-- Drawing from a Cox point process requires you to use another library, but it essentially works in the same way. -->
  
  <!-- ```{r} -->
  <!-- library(RandomFields) -->
  <!-- library(RandomFieldsUtils) -->
  
  <!-- draw_cox <- spatstat::simulate.kppm(fit_cox) -->
  <!-- plot(draw_cox) -->
  <!-- ``` -->
  
  <!-- Making goodness-of-fit tests is straightforward, we refer in particular to the functions `spatstat::quadrat.test`, `spatstat::cdf.test`, `spatstat::dclf.test` and `spatstat::mad.test`. -->
  <!-- A lot of these functions rely on multiple simulations of the point process, which is going to be exeedingly slow for the Cox process. -->
  <!-- Instead, we show what a goodness-of-fit test looks like with a simple fit with a Poisson point process. -->
  
  <!-- ```{r} -->
  <!-- dclf.test(fit) -->
  <!-- ``` -->
  
  <!-- ## Comparing the results -->
  
  
## Pre-modelling diagnostics

It is usually a good idea to start by a `static` analysis of the point pattern, without yet involving covariates.

```{r}
summary(configuration)

point_density <- spatstat.core::density.ppp(configuration, sigma = 1e5)
plot(log(point_density + 1e-11)) # a very small arbitrary value to avoid log of zero
points(configuration, pch = 16, cex = 0.2)

```


```{r}
###*********** You can ignore this Ian **********######
library(sf)

# make a grid with the size ncol = 20
grids <- sf::st_make_grid(rasters, n = 20, square = FALSE, what = "polygon") %>% 
  sf::st_sf() %>% 
  dplyr::mutate(id = 1:nrow(.))

rpoints <- terra::spatSample(rasters[[1]],
                  size = 100000,
                  method= "regular",
                  na.rm = TRUE,
                  as.points = TRUE) %>%
  sf::st_as_sf()
grids <- grids[rpoints,]

# count the numbers in the grid
occ_sf <- sf::st_as_sf(occurrences, coords = 1:2, crs = 7845)
grids$n_occ = lengths(st_intersects(grids, occ_sf))

ggplot() +
  geom_sf(data = grids, aes(fill = log(n_occ)), alpha = 0.7) +
  scale_fill_distiller(palette = 1, direction = 1, na.value = "white")

```


## Model selection with point process models


or do an ANOVA.




```{r}
# some few updated models with one less covariates
fit1 <- spatstat.core::ppm(configuration ~ 1 + bio_4 + bio_5 + bio_12, covariates = covariates)
fit2 <- spatstat.core::ppm(configuration ~ 1 + bio_4 + bio_5 + bio_15, covariates = covariates)
fit3 <- spatstat.core::ppm(configuration ~ 1 + bio_4 + bio_12 + bio_15, covariates = covariates)
fit4 <- spatstat.core::ppm(configuration ~ 1 + bio_5 + bio_12 + bio_15, covariates = covariates)
```

The ANOVA with highest reduction shows the variable with the highest impact on the model.

```{r}
anova(fit, fit1)
anova(fit, fit2)
anova(fit, fit3)
anova(fit, fit4)

```



## Fit Poisson process in Stan (Bayesian framework)

[](https://towardsdatascience.com/understanding-point-process-model-with-r-983553ca2a86)

```{r}
ppm_stan <- '
data{
  int<lower = 1> n;
  vector[n] x;
  int<lower = 0> y[n];
}
parameters{
  real beta0;
  real beta1;
}
transformed parameters{
}
model{
  //priors
  target += normal_lpdf(beta0 | 0,5);
  target += normal_lpdf(beta1 | 0,10);// likelihood
  target += poisson_log_lpmf(y | beta0 + beta1 * x);
}
generated quantities{
  vector[n] lambda_rep;
  lambda_rep = exp(beta0 + beta1 * x);
}'

```

