---
title: "Species distribution modelling with Poisson point processes"
subtitle: "The Quantitative & Applied Ecology Group (QAECO), The University of Melbourne"
author: "Ian Flint and Roozbeh Valavi"
date: "`r Sys.Date()`"
output: 
  pdf_document
vignette: >
  %\VignetteIndexEntry{Species distribution modelling with Poisson point processes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, tidy.opts=list(width.cutoff=80), fig.align="center", message = FALSE, warning = FALSE, fig.height=5, fig.width=5)

set.seed(42)
```

## Species distribution modelling

Species distribution modelling is...


The example data used in this tutorial comes form Fithian and others (2015).

## Envrionmental data


```{r}
# library(maptools)
library(raster)

grid_dir <- "data/grids"
vars <- list.files(grid_dir, pattern = ".tif$", full.names = TRUE)

# read the raster layers as a raster stack
r <- stack(vars)
# set the coordinate system to mercator / geographic coordinates
# the epsg code for geographic coordinates system is 4326
crs(r) <- CRS("+init=epsg:4283")
# transfer a metric coordinate system, here UTM South zone 56 is suitable
# the epsg code for this crs is 32756
nsw_stack <- projectRaster(r, crs = CRS("+init=epsg:32756"))
# you can plot them by:
# plot(nsw_stack)

```

## Species data
The species data comes form Fithian and others (2015).

All the species starts with `euca` ...

```{r}
library(sf)

# load Fithian et al (2015) species data
load("data/moddat.RData")

# show few rows and column in the species dataset
eucacine_moddat[1:5, 1:8]

# convert the data.frame to sf and convert the crs to UTM
eucacine_moddat <- eucacine_moddat %>% 
  st_as_sf(coords = c("long", "lat"), crs = 4326) %>%
  st_transform(crs = 32756)
# plot the sapecies on the raster map
plot(nsw_stack[[1]])
plot(st_geometry(eucacine_moddat), add = TRUE) # add only the locations/geometry
```


## Modelling with Maxent

Here we use `maxnet` package, the open-source version of `Maxent` in R. 

```{r}
# load the libraries
library(maxnet)
library(dismo) # for generating random points

```

Sampling random background from the landscape...

For the purpose of this tutorial, we random

```{r}
# generate some random samples
rnd <- randomPoints(nsw_stack, n = 10000)

# extracting the values of points
background <- raster::extract(nsw_stack, rnd)
head(background)

# check for any NA in the extracted values
anyNA(background)

# remove the NA values
background <- na.omit(background)

```

As the values in the presence data is already extracted, we just merge the data to make it ready for model fitting. Here, I make a `daata.frame` with only the covariates that is going to be used in model fitting.

```{r}
# subset the covariate in species data by raster
prcov <- eucacine_moddat[, names(nsw_stack)]

# now add them together
covariates <- rbind(prcov, background)

```

Now we can use this for model fitting...
the parameters...

Here, we need to make a voctor of 1s and 0s (for presence and background points respectively). This shoudl be with the same order as the covariate data is provided.

```{r fig.height=6.5, fig.width=7}
# make the presence and background points
# presnece (1s) and background (0s)
# the order should be the same as the order in the covariates
presences <- c(rep(1, nrow(eucacine_moddat)), 
               rep(0, nrow(background)))

tmp <- Sys.time()
mxnet <- maxnet(p = presences,
                data = covariates,
                regmult = 1, # regularisation multiplier
                maxnet.formula(presences, covariates, classes = "lqph"))
Sys.time() - tmp

# plot the fitted function
# plot(mxnet, type = "cloglog")

```

### Pridicting on rasters

To predict this model on rasters, you need a `RasterStack` with all the covariates used in model fitting. The names of the covariates in the `RasterStack` must be exactly the same. This is done through `raster` package (already loaded with `dismo` pcakage).

There are different options for scaling the raw output of `maxnet` including the **link**, **exponential**, **logistic** and recently introduced **cloglog**. For more information about these option please read Phillips et al. (2017).

```{r}
max_pred <- raster::predict(object = nsw_stack, model = mxnet, type = "cloglog")
# plot the prediction
plot(max_pred)

```

### Bias Correction

Creating a map of distance to the towns to correct for biases in the data.

```{r}
library(sf)

# the border shapefile
border <- st_read("data/ibraone.shp", crs = 4283, quiet = TRUE)
# reading the town point data
towns <- st_read("data/towns/ecologist_towns.shp")

plot(nsw_stack[[1]], main = "Towns in the region")
plot(st_geometry(towns), add = TRUE)

```

```{r}
distmap <- distanceFromPoints(nsw_stack[[1]], towns) # this may take some time
distmap <- mask(distmap, mask = border) # crop base on the region

plot(distmap)
points(eucacine_moddat$long, eucacine_moddat$lat)
```



## Modelling with point processes

The `spatstat` package is the most widely used to work with point processes.
Covariates are usually specified in their image objects `spatstat::im`.
Internally, this is represented as a large pixel matrix, so conversion from rasters and other image objects is usually straightforward.

```{r}
library(spatstat)

covariates <- lapply(as.list(nsw_stack), function(element) maptools::as.im.RasterLayer(element))
names(covariates) <- names(nsw_stack)
```

Spatstat also needs to be told what the observation region is.
The required object type is `spatstat::owin`.
Common ways to construct an `owin` is to either take a fixed rectangle, i.e. `window <- owin(c(0, 100), c(0, 100))`, or to use an existing covariate or raster to construct the window.
The latter technique is what we will use here.

Although it would be possible to do `window <- spatstat::as.owin(covariates[[1]])`, it will be easier to work on a window with a lower resolution, as shown next.

```{r}
window <- spatstat::as.owin(as.mask(covariates[[1]], eps = 0.01))
```

Locations of individuals are represented via a point pattern object `spatstat::ppp`, and consist in coordinates along with a window in which the species has been observed.

```{r}
configuration <- spatstat::ppp(x = eucacine_moddat$long, y = eucacine_moddat$lat, window = window)
```

Point patterns can easily be plotted.

```{r}
plot(configuration)
```

It is usually a good idea to start by a ``static'' analysis of the point pattern, without yet involving covariates.

```{r}
summary(configuration)
plot(spatstat::density.ppp(configuration))
plot(spatstat::Kest(configuration))
# The line below takes 3 min to execute and is not crucial to the analysis.
# plot(spatstat::envelope(configuration,Kest))
```

Doing inference on the point pattern is just as easy as setting up a `glm` regression.
Start by writing the formula, essentially `formula <- "configuration ~ covariates`

```{r}
formula <- paste0("configuration ~ ", paste0(names(covariates), collapse = " + "))
print(formula)
```

The fitting function (analogue of `glm`) is `spatstat::ppm` and is used as follows.

```{r}
fit <- spatstat::ppm(as.formula(formula), covariates = covariates)
```

The fitted regression is manipulated in the same way as a `glm` fit is, so for example you can have a look at the summary

```{r}
summary(fit)
```

or do an ANOVA.

```{r}
formula_without_bc04 <- paste0("configuration ~ ", paste0(names(covariates)[-2], collapse = " + "))
fit_without_bc04 <- spatstat::ppm(as.formula(formula_without_bc04), covariates = covariates)
anova(fit, fit_without_bc04)
```

To look at the predicted intensity, you use the `spatstat::predict.ppm` function.

```{r}
pred <- spatstat::predict.ppm(fit, covariates = covariates)
plot(pred)
```

Spatstat can handle many different types of correlation structures between individuals of the species.
You would usually supply an `interaction` parameter to `spatstat::ppm`.
However, initial analysis suggested attraction between the individuals, in which case a doubly-stochastic (Cox) point process is more appropriate.
Fitting such point processes uses another function, as shown below.

```{r}
fit_cox <- spatstat::kppm(as.formula(formula), covariates = covariates, clusters = "LGCP")
summary(fit_cox)
```

A nice way to appreciate the difference in the underlying model is to draw from the fitted distribution.
This can easily be done for the fitted Poisson point process.

```{r}
draw_ppp <- spatstat::simulate.ppm(fit)
plot(draw_ppp)
```

Drawing from a Cox point process requires you to use another library, but it essentially works in the same way.

```{r}
library(RandomFields)
library(RandomFieldsUtils)

draw_cox <- spatstat::simulate.kppm(fit_cox)
plot(draw_cox)
```

Making goodness-of-fit tests is straightforward, we refer in particular to the functions `spatstat::quadrat.test`, `spatstat::cdf.test`, `spatstat::dclf.test` and `spatstat::mad.test`.
A lot of these functions rely on multiple simulations of the point process, which is going to be exeedingly slow for the Cox process.
Instead, we show what a goodness-of-fit test looks like with a simple fit with a Poisson point process.

```{r}
dclf.test(fit)
```

## Comparing the results


